# 从本质上来谈谈Golang的值类型和引用类型

值类型：int、float、bool和string这些类型都属于值类型，使用这些类型的变量直接指向存在内存中的值，值类型的变量的值存储在栈中。当使用等号=将一个变量的值赋给另一个变量时，如 j = i ,实际上是在内存中将 i 的值进行了拷贝。可以通过 &i 获取变量 i 的内存地址。  值拷贝


引用类型：特指slice、map、channel这三种预定义类型。引用类型拥有更复杂的存储结构:(1)分配内存 (2)初始化一系列属性等一个引用类型的变量r1存储的是r1的值所在的内存地址（数字），或内存地址中第一个字所在的位置，这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。  

**两者的主要区别：拷贝操作和函数传参。**


> 注意我们所说的值类型引用类型本质上就是进行赋值或者参数传递等系列行为来进行区分的（就是通过赋值或者参数传递等系列行为是不是指向同一块内存空间来区分的），值类型就是拷贝，变量会重新开辟出内存空间，而引用类型指的是变量都指向这个内存空间，还有就是golang中只有值传递，引用类型变量传过去也是拷贝一份的


## slice介绍

```go
// 来看下slice的数据结构
//slice 从底层来说，其实就是一个数据结构
(struct 结构体) type slice struct {
ptr *[2]int
len int cap int
}
```

```go
var A [4]int =[4]int{1,2,3,4}
    fmt.Println(A)
    B :=A[0:3]
	fmt.Println(B)
    fmt.Println(&A[0]) // 0xc0000a0000
    fmt.Println(&B[0]) // 0xc0000a0000 肯定一样啊 因为B[0]这个操作就是他里面strcut指向的
    fmt.Println(&B) // &[1 2 3]
	fmt.Printf("A指针是 %p\n",&A) // 0xc00009c000
    fmt.Printf("B[0]指针是 %p\n",&B[0]) //  0xc00009c000
	fmt.Printf("B指针是 %p",&B) // 0xc0000a6000
	// 指向这个slice的内存指针跟A确实不一样 那肯定啊 内存得有帮slice开辟内存的
```

-  slice A变量本身需要开辟一块内存空间存放 而这块内存空间又存放着一个地址 这个地址指向数组B
-  slice不管以哪种方式初始化底层都会有一个数组



## 总结
- 数组进行slice(切片)操作

- 区分好值类型和引用类型都知道本质 当你对变量进行一系列操作时候，参数还是变量指向的内存是不是同一块就行

- slice内存不需要我们进行make开辟，会帮我们自动开辟好内存的，但是map等引用类型就需要我们自己去开辟


```go
// 这是一个使用例子
type a struct{
	a []int //直接使用无需分配内存
	b map[string][string] // 需要手动分配内存 make分配内存
}
// 遗憾的是我没有找到一篇关于分配内存的文章 以后遇到或者明白了再补上
```

